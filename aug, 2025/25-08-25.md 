## Todo/ Logs
- [x] spend 6 focused sessions on algo
- [ ] do 1 deep work session working on rss feed projec


- Logs: x : 0 ; y : 5 


## Topics

- algorithms
	- factorial 




## Notes
- algorithms
	- concept: factorial
		- i have a general idea about recursion
		- recursion is all about subproblems
		- there is a base case (always) in recursion 
	- problem: reverse linked list
		- i have actually tried this problem before and struggled with it for some time and then watched the solution
		- first of all , let me try to understand the problem statement well enough
		- as far as i remember, i am supposed to use a simple approach (which ofc i don't remember)
		- i am right now just focused on getting this problem solved and not using recursion; once i am done with the basic solution, i will be using the recursive approach
		- light went off; but i will complete the session
		- i am smelling a two pointer kind of approach here
		- okay; so I saw the solution; but i will be spending time later two implement both the solutions on my own
			- both the solutions (iterative and recursive ) seem fairly simple; but have a hint of eureka
			- give some time to understand these problems
			- back to trying it again; but i am still struggling with it; this is an important pattern
			- i think i have cracked the core logic of reversing the linked list; but i am missing something in the solution
			- yes, did it finally. 
			- now, onto the recursive approach
				- the recursive solution is a bit hard to think about initially (afraid to make mistakes; get rid of this) 
				- let's try to think about this from fundamentals
				- recursion usually involved a base case and a recursive case
				- we need to reverse a linked list; so first thing i need to do is find out which is the base case and which is the recursive; let's do the simple thing first, finding the base case
				- what is the base in this problem: having a single node whose next is pointing ot 
			- could not figure out the recursive approach on my own; the solution did not make too much sense too
			- watching the solution video
				- i did not understood the recursive solution really; i will need to try to come up on my own to really get it. 
	- concept: fibonacci seq
		- lec on hold
	- problem: climbing stairs
		- number of ways to reach the top of the staircase
		- 1 + 1 + 1 = 3 and 2 + 1 = 3 and 1 + 2 = 3 are the three unique ways for n =3 
		- the idea is simple, but not able to come up with a clear solution
		- did solve it with trial and error , but not really understood it well enough. 
		- solution:
			- watched first how recursion works using fibonacci example
			- this is actually a foundational dynamic programming problem
			- this is an incredible problem; i must revisit it. 
			- i learnt about decision trees and how they are used; they are pretty pretty cool. 
			- got a hint of memoization
			- i can't stop praising this problem; it is that beautiful. just wow. 
			- this problem is essentially a wrapper over fibonacci (if you think deeply) 
			- absolutely revisit this problem; i would say just do this enough times. 
	- concept: insertion sort
		- the core idea is solving sub problems
		- a single element is always sorted (single element array) 
		- i will need to dry run this algorithm and spend some time understanding the core idea; spend 2 -session on it. 
