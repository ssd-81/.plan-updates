2025-09-08
## todo/logs 
- [x] do 4 hour focus block 

- logs => x = (1); y = (1) 


## notes 
- algorithms 
	- concept: sets and maps
		- internet was pretty slow; so did not got anything done. 
		- no audio, so was not able to get the idea very clearly. went over the bare minimum. putting this on hold for now. 
		- watching it again
		- sets are similar to arrays; but only difference being, no repetition allowed. 
		- maps are key value pairing and the data is sorted by the keys. 

	- concept: backtracking
		- it utilizes the dfs algorithm
		- best way to understand such ideas would be through an example: find whether there exists a path from root node to a leaf node. 
		- to understand backtracking, we must have a general idea of brute force; it is a common algorithmic technique where we try to use all possible solutions to get to the real solution. 
		- very less retention and actual understanding. will need to watch it again. 	
		- try to understand the leafPath code on your own by spending some time on trying to fix it yourself. 
		- revisit it again and try to explain yourself the basic idea in clear terms along with visual. 
		- visiting this idea again to get a better understanding of this. 
		- much better understanding than the time I tried to push half baked understanding. 
		- backtracking is not as easy of a concept as it might seem; but it is pretty rewarding and opens up new avenues to approach a problem. 
			````python
def leafPath(root, path):
    if not root or root.val == 0:
        return False
    path.append(root.val)

    if not root.left and not root.right:
        return True
    if leafPath(root.left, path):
        return True
    if leafPath(root.right, path):
        return True
    path.pop()
    return False
````
		- learning backtracking well enough is a pretty good start for developing serious interview level skill. 
	- problem: path sum 
		- If I am being honest, this problem seems like a direct instance of the ideas discussed in the concept introduction; but I should prove that first. 
		- Not so trivial as I thought; this question is not trivial; at least from my vantage point. 
		- the integer value of each node can be negative integers as well; so will need to figure out that as well; when do actually backtrack, it is the real question here. 
		- I was able to solve that; it was somewhat copy pasting the core idea I learnt ; but  I would say I did had around >50% understanding. 
	
	- problem: subsets
		- this problem requires us to generate all the subsets of a given set. 
		- 2^n is the total number of subsets of a given; n is the number of elements in given set. 
		- first question: how does this question use backtracking or any similar idea?
		- this is absolutely not a trivial problem; it does require me to construct an approach in my mind before I write my solution. good problem. 
		- I will try to spend a minimum of 45-min on this problem before I watch the solution; the struggle is important; at least initially. 
		- without having a proper approach, I am like a man without compass; I am having an idea how it could be done, but it is pretty pretty vague. 
		- I was not even able to lay out a basic approach to this problem. This seemed somewhat out of reach. This is an important question to revisit. 
		- **is backtracking the same as brute force**
		- this solution was very very incremental and iterative; I realized how some seemingly difficult problem require a different approach than coming up with a solution right away. 
		- I did understood the general idea of the solution; but I am far from understanding the actual code written. Let me try to read that and get some insights. 
		- This is still pending. 
