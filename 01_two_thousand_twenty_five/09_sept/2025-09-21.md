2025-09-21

## Todo/ Logs
- [ ] 4-hour deep work session 
- [ ] Review 2 ideas from DSA

## Notes
### Systems
- decide the cost for what you want and be willing to pay for it. 
- the selfishness illusion (selfish, stupid, burden)
	- the best option is selfish, being burden or stupid does not really help anyone. 
	- society expects you will handle your selfishness with some grace and compassion. 
	- you eventually want to give more than you consume. 
	- p1: fitness, eating right, career, quality time => fall short at this and you slip into stupid (p2) and it is very easy to go from there to burden(p3). 
	- At every turn, we cheat our own future to appear generous today. 
	- Being selfish does not mean being a sociopath. It just means taking a long view of things. 
	- Apparently humans are wired to take care of their own needs first, then family, tribe, country, and the world, roughly in that order. 
	> **The healthiest way to look at selfishness is that it's a necessary strategy when you are struggling**
- **The Energy Metric**
	- we want a lot of things; good health, financial freedom, accomplishments, social life, love, sex , travel ..., the list goes on. 
	- the problem is that once you focus on one, you cannot focus on other, and it is kind of a serious problem. 
	- one ring to rule them all: **energy**
	- do things that keep your energy high. 
	- reference: the dog whisperer model 
	- think of managing energy as managing finances in a company. 
	- think of trade-off design; short term impression don't really matter , if you can craft something amazing in the long haul. 
	- remember, most people don't have the luxury of flexible schedule; the next best thing you can do is fix you sleep and wake up time, use the blocks you get in between to craft something amazing. 
	- do give a thought to becoming a morning person; it does have a lot of power. 
- simplifiers v optimizers
	- a simplifier is a person who looks for the easy way to accomplish a task
	- an optimizer looks for the best solution even if the extra complexity increases the odds of unexpected problems. 
	- one is not inherently better than the other; it is about tradeoffs, which is almost true for most good problems. 
	- simple is good when people are involved (think communication). 


### Algorithms
- problem: Course scheduling
	- Following the solution. 
	- an idea that is absolutely remarkable and just I can't explain how beautiful it is. 
	- ![[idea.png]]
	- this problem is a great for building intuition regarding an idea in graphs (cycles). 
- concept: 1D Dynamic Programming 
	- a good place to start understanding dynamic programming is simply understanding recursion; and further, fibonacci sequence; we can generate fibonacci sequence and look at its tree representation (for f calls), it takes quite a lot of space and compute. DP solves this to an extent. 
	- introducing memoization 
		- the core problem we were encountering in the brute force recursive solution for fibonacci is that a lot of function are repeated. 
		- memoization allows us to cache function calls and use them again (I think I am not phrasing this correctly)
		- ![[dynamic_programming.png]]
		- memoization = top down dynamic programming
			- some people don't consider this dynamic programming
		- bottom up dynamic programming
			- the true dynamic programming
		- the core idea that I have understood is that dp allows us to break a large problem and break it down into smaller problem (so optimization, right). 
	- problem: Climbing Stairs
		- I have already solved this problem, but this time I need to solve it using DP. 
		- This problem looks incredibly simple, but it is pretty good if you actually try to understand the underlying logic; I mean it is clearly not trivial, but it is worth spending time on. 
		- solved it, but I don't understand the recursive : f(n-1) + f(n-2) call 
		- also, I solved only using memoization and not bottom up approach. 
		- solution
			- I am realizing why we might have done the f(n-1) + f(n-2) call; but still very unsure. 
			- I realized that I was not reading the problem properly; it is clearly stated in the problem that we can either take 1 or 2 steps at a time. 
			- hint: when to use dynamic programming: when problems are being repeated, likely the best way forward is DP or at least consider it. 
			- the idea of memoization vs bottom up approach is somewhat confusing to me. I am not clear with the distinction. 
	- problem: House Robber
		- a really clever problem and absolutely fun to think about. 
		- we cannot rob two adjacent houses, and we need to rob the max amount of money from an area. 
		- the problem requires me to design a system where I can maximize the value and I am sensing a tree structure for making decisions. 
		- I am getting  a DP approach in mind; but not really certain about it, i don't even know if this is TD or BU.
	