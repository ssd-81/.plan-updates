## Todo/ Logs
- [ ] 8^x algorithms
- [ ] 6^x backend 

- Logs: x : 0 ; y : 5


## Topics 
- algorithms


## Notes
- algorithms 
	- problem: koko eating banana
		- continued; I was working on this problem yesterday. 
		- this problem seems very similar to the problem: first bad version; I think I can transfer that mental construct here
		- Here's an approach I am thinking:
			- find the max and the min value of bananas in all of piles 
			- now set k to mid 
			- if k is fulfilling the conditions; accordingly adjust the max and min value of bananas
			- the proposed solution actually worked to some extent; one of the test cases passed.
			- I think I am moving in the right direction. 
			- multiple edge cases are creating issues. the solution seems fine at first, but there are many minor issues which need to be resolved. 
			- analyszing the code with a deeper lens. 
			- facing the issue of not returning the correct value (off by one style error) 
			- could not figure out the solution; watched the solution spending about 2-3 sessions thinking about the problem (scattered thinking):
				- the solution is thought in steps ; brute force progresses to optimized 
				- every step is a valid step
				- understand the constraint really really well. 
			- so I interrupted the solution in between and started solving because a spark came in my mind; 
				- the newly proposed solution uses a result variable to store the solution as we iterate, rather than using the mid to preemptively exit with the incorrect solution. 
				- the new sol is actually passing the test case which the previous failed, but I am facing new issues (:})
				- a single change and wow, done. 
				- I used a separate function rather than handling the valid solution check in the same function. 
	- concept: binary trees
		- binary trees are one of the most complex data structures we have encountered till now; it uses ideas from all of the ds we have looked so far. 
		- knew most of the things mentioned in the concept vidoe
	- concept: BST
		- on hold, first I will try the assigned problem
		- a bst is a special binary tree, where all left sub tree elements are all less than the root (current) and right elements are greater than root val
		- searching an element in bst is logn (assuming the tree is balanced) 
		- why do we need bst data structure if we can have sorted arrays and use binary search in them? (interesting question) 
			- 
	- problem: search in a binary search tree
		- i was expecting this to be far more simpler than I thought; but I am struggling to figure out a way to iterate all the nodes
			- not effectively, but just all nodes for now. 
		- okay, so I realized something critical; this is a bst and not a binary tree. I don't need to search the entire tree, but use the definition of BST to check if the number exists or not. 
		- wrote the solution, but the time limit is exceeding. 
		- made a silly error; actually it happens more often than you think; but still the solution is failing a few edge cases
> i need to make a rule to open only 2-3 tabs while working on problems and be hyper specific when I open something; what I am expecting from that etc. 
		- I am stuck without having enough information to make up the case for what is causing the problem. 
		- asked for some help from gpt; did point out where I was making mistake; but still not clear; will be continued later. 

	
