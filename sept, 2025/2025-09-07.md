2025-09-07

## todo/logs
- [x] get the 4 hour deep work session right. 

- logs => x = (1); y = (1)

## notes

- rss project 
	- commands addfeed and follow are not showing proper error messages while using the commands 
		- understand the flow of execution of commands in the code 
		- had to take some help of gpt agent; but it was a really minor bug; but I realized I don't even try to fix such issues; I right away make up my mind that I can't solve it.
		> build a process to look for problems in your code actively.

- algorithms
	- problem: construct binary tree using inorder and preorder traversal 
		- I have already tried to solve this problem ; but the previous attempt was half baked. Let me try to spend a good 45 min on this problem. 
		- I am not able to think how to start, even though I am getting a vague solution in my mind. 
		- the understanding I have built from last time is not very different; but is is incremental and pretty good. don't let this momentum lose. 
		- I am stuck with a particular logic where I am supposed to use recursion or something similar to make another call to the buildTree method; but I am not sure how to pass the preorder part to recursive call 
		- I think writing this using recursion is going to be difficult; I am going to try iteration. 
		> got a bit distracted in between. planning disease. 
		- started watching the solution; and got a hang of solution in between; let me try that out. 
		- when I started writing solution; I got stuck at the same place; I will try to understand the solution first. my process is very raw and does not have scalability yet. 
		- watched the solution completely end to end. now i will try to write the solution completely from memory and some logic
		- passed the solution in first try; ofcourse I remembered most of the logic, but it did require me to intentionally think about edge cases and core logic. 
	
	- concept: breath first search
		- traversing a tree (any tree) layer by layer
		- this algorithm does not suit recursion; because the two pointer problem. 
		- it is also termed as 'level order traversal'
		- implementation of bfs is usually done using a queue
			- popleft() , append() on a deque (by default, python provides it)
	
	
	- problem: level order traversal
		- this problem just requires me to apply the breath first search algorithm. 
		- this seemed easy before I started writing the solution; confusion creeps in, questions arise. 
		- I have got an idea to write the solution for this; but I am not getting how to parse the output such that it fits the condition required by the function signature. 
		- I am actually trying to copy pasta the entire algorithm I watched in the idea video. 
		- use your own mind, think what the problem really requires, before directly jumping to the solution. 
		- I tried coming up with the solution for some time (around 25-min); now I am moving to watching the solution
		- saw the solution; now the recollection process. 
		- I am struggling to recall the solution from memory; I am missing out on critical components. 
		- rewatching the solution again to get a better idea. 
		- from my observation, i am lacking thinking on my own part of the solution; i am kind of regurtitating the solution in a way; i am not stressing myself enough where there is actual thinking required. 
		- watched the solution once again, let me try to write the solution again this time. 
		- progressed much better than the last attempt, but rn strangling with the interpreter related issue ; I am not even phrasing it right. 
		- had to chatGPT to find a bug; bad on my part !
		- but I learnt a very important finding; don't trust the compiler/interpreter message blindly; the issue was not on the line interpreter was pointing to, it was near the very end; i was not appending to res, but the iterating variable itself, which caused malfunction. 
	

	- problem: binary tree right side view
		- the problem seems quite simple on my first look, let me get back after trying to write the solution. 
		- I have got two approaches in mind: one using recursion and the other simply using iteration (or some kind of similar model) 
		- I tried to write a recursive solution, and it was written in a way, that I was expecting a miracle to happen if I just manage to structure a seeming solution. You have to think hard my man. 
		- failing an edge case where the input is two elements and I am missing by one element. 
		- i am sensing that I am not interpreting this problem correctly; what do we mean by visible from right side of the tree
		- so, I was actually not understanding in the first place, when I tried to better understand the problem, I was actually able to realize the underlying pattern in the question and simply used the bfs algorithm and made a few tweaks and waalah!, the solution was done.
		- learning a few meta patterns ,here and there. going slow, but good. 
		- but still, let's check the solution video, if there is a better approach to solve this problem. 
		- the author of the solution said something interesting: most tree related problems can be solved using DFS; pretty pretty intersting. 
		- the solution video used the same approach I used; but the only minor difference being that the solution did not store the value of entire level; but simply one value at a time and the last value that would be stored will automatically be the required rightmost value 
		- the dfs based solution requires some pen paper analysis; putting this on hold for now. 

