2025-09-18

## todo/ logs
- [ ] solve 3-problems and revisit 3 problems 



## notes
### algorithms
- problem: shortest path in binary matrix 
	- started with reviewing the gemini chat around the same problem. 
	- the structure I am using currently does not really target this problem specifically. It is like trying to fit in a recipe in another recipe. This ain't original and to be precise, not solving the problem. 
	- also, it is likely that I am not trying to work on this problem from a holistic lens; I mean , instead of actually thinking what I should do, I simply try to use the formulaic approach. give some time to the problem and try to get to the idea. 
	- did some pondering and got a clearer understanding of the problem 
	- facing issues while storing distance for each path; not sure where to exactly do that. 
	- did some restructuring of the code (had to ask gemini a bit)
	- **BFS by design finds the shortest path** : think about this. 
	- got pretty close to the solution; likely just off by one. 
	- a lot of test cases have passed; just need to get around 3 more. but you never know, if you have to write the entire routine if there is a core problem with the concept. 
	- facing some interesting design related problems due to edge cases; but for some reason, each failing edge case is improving my understanding and challenging me to rethink my solution. 
	- got it done. 
	- solution : 
		- understand the structure of the question, how questions are asked. 
		- getting the pattern right is critical. 

- problem: rotting fruit
	- the general idea of the algorithm is pretty interesting and is an incremental change to the thinking around graph problems. 
	- we need to figure out the smallest time interval in which all fruits will rot, if it is not attainable, then we simply return -1. 
	- from what I understand, I am seeing a model that might be applicable here; there is one or more rotten fruits in the grid; we are looking if all the rotten fruits in the grid can spread to the entire grid; so this is exactly the bfs mechanism of spread; we need to model the spreading mechanism using this idea. let's call it directionality growth for now ( a cool name for sure). 
	- I am not able to think how we are going to incorporate the idea of time in this problem; I mean the base idea seems pretty accurate to me, but getting the time idea right is another problem. 
	- multi source bfs problem. 
	- can we call this a parallel algorithm? 
	- jumping to the solution; because this idea is somewhat new to me, so I will sow the seed for now (after spending just about ~30-mins on my own); I have just got a hint how to approach this problem. 
	- this is one of the problems that is really hard to solve without bfs; I am not sure if it can be solved using DFS or not. 


### backend engineering

#### HTTP servers in Go
- Stateful handlers
	- have been stuck with this problems for quite some time now, and this is getting more difficult as I am starting to get static. 
	- I am finding it insanely difficult for some reason, am I too tired or what, but I am feeling like this is the most difficult thing I am working on. 
	- got error related to status code, I will check. 
- Routing
	- we are going to use go standard lib for routing, but other tools exist too: gorilla mux , chi. 
	- read about MUX, best practices , etc
- Architecture 
	- Monolith
		`A monolith is a single, large program that contains all of the functionality for both the front-end and the back-end of an application.`
		- monoliths in simple words; mean a single codebase for handling both backend and frontend (are you sure???)
	- Decoupled
		- front-end and back-end are separated into different codebases. 
		- do some further research to understand it better. 
	- Specifics
		- I need to restructure the application so that the we decouple. /api and /app. 
	- Which is better?
		- **the standard question for every good problem**
		- the usual answer for this standard question: its about **tradeoffs**
	- This is a really interesting idea; no doubt it is absolutely fascinating. 


### systems thinking
> Failure is where success likes to hide in plain sight. 

- Good ideas have no value because the world already has too many of them. The market rewards execution, not ideas. 
